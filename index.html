<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pablo Bazan | Creative Technologist</title>
    <style>
        /* --- ESTILOS CSS (Sin cambios mayores respecto a V7) --- */
        :root {
            --cursor-x: 50%;
            --cursor-y: 50%;
            --spotlight-size: 350px;
            --primary-glow: #00f3ff;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #030303;
            background-image: radial-gradient(circle at center, #0e0e0e 0%, #000000 100%);
            overflow: hidden;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            height: 100vh;
            width: 100vw;
            cursor: none;
        }

        .noise-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            z-index: 99; opacity: 0.05;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        #bgCanvas { position: absolute; top: 0; left: 0; z-index: 1; }

        .content-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 1200px; text-align: center; z-index: 10;
            user-select: none; pointer-events: none;
        }

        h1, p, a { margin: 0; text-transform: uppercase; letter-spacing: 0.2em; }
        h1 { font-size: 5rem; font-weight: 900; margin-bottom: 20px; line-height: 1.1; }
        p { font-family: 'Courier New', Courier, monospace; font-size: 1.1rem; margin-bottom: 45px; letter-spacing: 0.3em; font-weight: 300; }
        a { display: inline-block; font-size: 1.2rem; text-decoration: none; padding: 15px 40px; letter-spacing: 4px; }

        .text-dimmed { position: relative; color: #151515; z-index: 11; }
        .text-dimmed a { pointer-events: auto; color: #2a2a2a; border: 1px solid #2a2a2a; transition: all 0.4s ease; }
        .text-dimmed a:hover { border-color: var(--primary-glow); color: var(--primary-glow); box-shadow: 0 0 30px rgba(0, 243, 255, 0.3); text-shadow: 0 0 10px var(--primary-glow); background: rgba(0, 243, 255, 0.05); }

        .text-lit {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; color: #ffffff; z-index: 12; pointer-events: none;
            -webkit-mask-image: radial-gradient(circle var(--spotlight-size) at var(--cursor-x) var(--cursor-y), black 0%, rgba(0,0,0,0.8) 40%, transparent 70%);
            mask-image: radial-gradient(circle var(--spotlight-size) at var(--cursor-x) var(--cursor-y), black 0%, rgba(0,0,0,0.8) 40%, transparent 70%);
        }
        .text-lit p { color: #ffffff; font-weight: 500; -webkit-text-stroke: 0.5px var(--primary-glow); text-shadow: 0 0 5px var(--primary-glow), 0 0 15px var(--primary-glow); }
        .text-lit h1 { animation: glitch-skew 3s infinite linear alternate-reverse; }
        .text-lit h1::before { content: "PABLO BAZAN"; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #030303; opacity: 0.8; color: #ff00c1; z-index: -1; clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%); transform: translate(-2px, 0); animation: glitch-anim-1 2.5s infinite linear alternate-reverse; }
        .text-lit h1::after { content: "PABLO BAZAN"; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #030303; opacity: 0.8; color: #00fff9; z-index: -2; clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%); transform: translate(2px, 0); animation: glitch-anim-2 2s infinite linear alternate-reverse; }
        @keyframes glitch-anim-1 { 0% { clip-path: inset(20% 0 80% 0); transform: translate(-2px, 1px); } 100% { clip-path: inset(30% 0 50% 0); transform: translate(1px, -1px); } }
        @keyframes glitch-anim-2 { 0% { clip-path: inset(10% 0 60% 0); transform: translate(2px, -1px); } 100% { clip-path: inset(40% 0 30% 0); transform: translate(-2px, -1px); } }

        #custom-cursor { position: fixed; top: 0; left: 0; width: 20px; height: 20px; border: 1px solid rgba(255, 255, 255, 0.8); border-radius: 50%; pointer-events: none; z-index: 100; transform: translate(-50%, -50%); transition: width 0.2s, height 0.2s; mix-blend-mode: difference; }
        #custom-cursor.hovered { width: 50px; height: 50px; background: rgba(255,255,255,0.1); border-color: var(--primary-glow); }

        @media (max-width: 768px) { h1 { font-size: 2.5rem; letter-spacing: 5px; } p { font-size: 0.8rem; letter-spacing: 2px; } a { padding: 12px 25px; font-size: 1rem; } :root { --spotlight-size: 250px; } }
        @media (max-height: 500px) and (orientation: landscape) { .content-container { top: 50%; transform: translate(-50%, -50%); width: 95%; } h1 { font-size: 2.2rem; margin-bottom: 10px; } p { font-size: 0.8rem; margin-bottom: 15px; } a { padding: 8px 20px; font-size: 0.9rem; margin-top: 5px;} }
    </style>
</head>
<body>

    <div class="noise-overlay"></div>
    <div id="custom-cursor"></div>
    <canvas id="bgCanvas"></canvas>

    <div class="content-container">
        <div class="text-dimmed">
            <h1>Pablo Bazan</h1>
            <p>Amante de la tecnología y del arte</p>
            <a href="https://es.linkedin.com/in/pablobazan" target="_blank" onmouseenter="hoverCursor(true)" onmouseleave="hoverCursor(false)">LINKEDIN</a>
        </div>
        <div class="text-lit">
            <div class="content-wrapper">
                <h1>Pablo Bazan</h1>
                <p>Amante de la tecnología y del arte</p>
                <a href="#">LINKEDIN</a>
            </div>
        </div>
    </div>

    <script>
        const cursorEl = document.getElementById('custom-cursor');
        const root = document.documentElement;
        
        let mouse = { 
            x: window.innerWidth / 2, 
            y: window.innerHeight / 2, 
            isMoving: false,
            timer: null 
        };

        function updateCursor(x, y) {
            mouse.x = x;
            mouse.y = y;
            mouse.isMoving = true;
            clearTimeout(mouse.timer);
            mouse.timer = setTimeout(() => {
                mouse.isMoving = false; 
            }, 100);

            root.style.setProperty('--cursor-x', x + 'px');
            root.style.setProperty('--cursor-y', y + 'px');
            cursorEl.style.left = x + 'px';
            cursorEl.style.top = y + 'px';
        }

        window.addEventListener('mousemove', (e) => updateCursor(e.clientX, e.clientY));
        window.addEventListener('touchmove', (e) => updateCursor(e.touches[0].clientX, e.touches[0].clientY), {passive: true});
        
        window.hoverCursor = (active) => {
            if(active) cursorEl.classList.add('hovered');
            else cursorEl.classList.remove('hovered');
        }

        // --- MOTOR DE FÍSICA MEJORADO ---
        const canvas = document.getElementById('bgCanvas');
        const ctx = canvas.getContext('2d');
        let particlesArray;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initParticles();
        }

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.vx = (Math.random() - 0.5) * 0.5; // Velocidad inicial más lenta
                this.vy = (Math.random() - 0.5) * 0.5;
                this.size = (Math.random() * 2.5) + 1;
                this.type = Math.floor(Math.random() * 3);
                this.angle = Math.random() * Math.PI * 2;
                const chars = "10<>_*/.[]{}";
                this.char = chars.charAt(Math.floor(Math.random() * chars.length));
                this.baseColor = '#666'; 
                this.color = this.baseColor;
                this.friction = 0.96; // Más fricción para movimientos más suaves
            }

            draw() {
                if (!mouse.isMoving) {
                    let dist = Math.hypot(mouse.x - this.x, mouse.y - this.y);
                    if (dist < 250) this.color = '#00f3ff';
                    else this.color = this.baseColor;
                } else {
                     this.color = this.baseColor;
                }

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.strokeStyle = this.color;

                if (this.type === 0) { ctx.beginPath(); ctx.arc(0, 0, this.size, 0, Math.PI * 2); ctx.fill(); } 
                else if (this.type === 1) { ctx.beginPath(); ctx.moveTo(0, -this.size * 2); ctx.lineTo(this.size * 2, this.size * 2); ctx.lineTo(-this.size * 2, this.size * 2); ctx.closePath(); ctx.stroke(); } 
                else if (this.type === 2) { ctx.font = '12px monospace'; ctx.fillText(this.char, -4, 4); }
                ctx.restore();
            }

            update() {
                this.angle += 0.005; // Rotación más lenta
                let dx = mouse.x - this.x;
                let dy = mouse.y - this.y;
                let dist = Math.hypot(dx, dy);

                // --- FÍSICA MOUSE SUAVIZADA ---
                if (mouse.isMoving) {
                    // REPULSIÓN SUAVE
                    if (dist < 150) {
                        let force = (150 - dist) / 150;
                        // Fuerza reducida drásticamente (antes *3, ahora *0.5)
                        this.vx -= (dx / dist) * force * 0.5; 
                        this.vy -= (dy / dist) * force * 0.5;
                    }
                } else {
                    // GRAVEDAD SUTIL
                    if (dist < 300 && dist > 50) {
                        let force = (300 - dist) / 300;
                        // Atracción apenas perceptible (antes *0.4, ahora *0.05)
                        this.vx += (dx / dist) * force * 0.05;
                        this.vy += (dy / dist) * force * 0.05;
                    }
                }

                this.x += this.vx;
                this.y += this.vy;
                this.vx *= this.friction;
                this.vy *= this.friction;

                // Rebote en pantalla
                if (this.x < 0 || this.x > canvas.width) this.vx = -this.vx;
                if (this.y < 0 || this.y > canvas.height) this.vy = -this.vy;

                this.draw();
            }
        }

        function initParticles() {
            particlesArray = [];
            let divisor = window.innerWidth < 768 ? 4000 : 2800; 
            let nParticles = (canvas.width * canvas.height) / divisor;
            for (let i = 0; i < nParticles; i++) {
                particlesArray.push(new Particle());
            }
        }

        function connect() {
            const connectDistance = 110;
            // Distancia mínima para activar la separación entre partículas
            const separationDistance = 50; 

            for (let a = 0; a < particlesArray.length; a++) {
                // Empezamos desde a+1 para no comparar consigo mismo ni repetir pares
                for (let b = a + 1; b < particlesArray.length; b++) {
                    let dx = particlesArray[a].x - particlesArray[b].x;
                    let dy = particlesArray[a].y - particlesArray[b].y;
                    let dist = Math.hypot(dx, dy);

                    // --- NUEVO: FÍSICA DE SEPARACIÓN ENTRE PARTÍCULAS ---
                    // Si están demasiado cerca, se empujan suavemente entre sí
                    if (dist < separationDistance && dist > 0) {
                         let force = (separationDistance - dist) / separationDistance;
                         // Un empuje muy sutil para mantener el "espacio personal"
                         let pushX = (dx / dist) * force * 0.03;
                         let pushY = (dy / dist) * force * 0.03;
                         
                         // Aplicar fuerza a ambas partículas en direcciones opuestas
                         particlesArray[a].vx += pushX;
                         particlesArray[a].vy += pushY;
                         particlesArray[b].vx -= pushX;
                         particlesArray[b].vy -= pushY;
                    }
                    // ---------------------------------------------------

                    // Dibujar líneas si están cerca (lógica original)
                    if (dist < connectDistance) {
                        let opacity = 1 - (dist / connectDistance);
                        ctx.strokeStyle = 'rgba(180, 180, 180,' + opacity * 0.7 + ')'; 
                        ctx.lineWidth = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                        ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                        ctx.stroke();
                    }
                }

                // Conexiones al Mouse (Solo si está quieto)
                if (!mouse.isMoving) {
                    let mouseDist = Math.hypot(particlesArray[a].x - mouse.x, particlesArray[a].y - mouse.y);
                    if (mouseDist < 250) {
                        let opacity = 1 - (mouseDist / 250);
                        ctx.strokeStyle = 'rgba(0, 243, 255,' + opacity * 0.8 + ')';
                        ctx.lineWidth = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                        ctx.lineTo(mouse.x, mouse.y);
                        ctx.stroke();
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
            }
            connect();
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        animate();

    </script>
</body>
</html>